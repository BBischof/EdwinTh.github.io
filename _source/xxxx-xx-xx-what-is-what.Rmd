---
layout: post
categories: blog
title: "Tidy evaluation, what is what"
base-url: https://EdwinTh.github.io
date: "2017-08-25 20:30:00"
output: html_document
tags: [R, dplyr, tidy evaluation, programming, non-standard evaluation]
---

This a bit of a follow-up to a post I did earlier on [tidy evaluation](https://edwinth.github.io/blog/dplyr-recipes/). This time I want to explore the different objects that come with NSE programming. Where the previous blog was a quick *How-to* reference guide, this is one a more lengthy *what-is-what in NSE*. As with many aspects of the tidyverse, most of the concepts within tidy evaluation are not new, but rather a reimplementation of base R concepts. What makes this one so challenging however, is that the [Honorable Doctor Sir Lord General](http://maraaverick.rbind.io/2017/08/tidyeval-resource-roundup/) and friends brought concepts to the realm of the mortals that many of us had no or only a vague understanding of. Writing this blog post was a way for me to understand the terms used. What they are in base R and how they are different in tidy eval. Therefore it is almost surely incomplete and it is possibly erroneous at places. People with a deeper understanding than I have, are encouraged to improve this writing by PR or email.

I listed a number of terms and started studying them. Mainly consulting chapters 17 and 18 of [Advanced R](http://adv-r.hadley.nz/) and the [R Language Definiton](ftp://cran.r-project.org/pub/R/doc/manuals/r-release/R-lang.html).

# Base R, non-standard evaluation

## `expression`

In standard evaluation R is like a child receiving candy from his grandmother and puts in his mouth directly. Every input is evaluated right away. This can be collecting the value of an object or letting a function make a calculation. An `expression` is some R code that is ready to be evaluated (a statemetn), but is not evaluated yet. This is the child's parent telling he can't have the candy untill they get home. The typical way of creating an expression is by using `parse(text = "<string input>")`. Here we are creating an expression of length 1. Note that the `text` argument is not the first argument of `parse()` and thus must be named.

```{r}
expr <- parse(text = "5 + 5")
expr
```

To **evaluate** expression we run it by `eval()`.

```{r}
eval(expr)
```

When giving multiple lines to `parse()` it will create a list-like object of multiple `expressions`. When passing the full expression to `eval()`, only the evaluation of the last element is returned.

```{r}
multi_exp <- parse(text = c(
  "x
   3 + 3"
))
multi_exp %>% class()
multi_exp %>% length()
multi_exp[[1]]
multi_exp[[1]] %>% class()
```

Hmmm, the first element of the expression is of class `name`. What's up with that?

## `name`

When creating an object in R, you are binding the name of the object to a value. In the following the name `x` gets associated with the value 50.

```{r}
x <- 50
```

Normally we type this name to request it value. However in NSE we delay evaluation and we just save the name to be requested later. So the `name` is a subset of the `expression` where the unevaluated R code is retrieving the value of an object.

```{r}
x <- parse(text = "x")
eval(x)
```

This way we can build a request for later. The variable requested for doesn't even have to exist at creation time. (Like granny having no candy herself, but telling the kid that he can have candy when he gets back at his parent's place).

```{r}
eval_me <- parse(text = "y")
eval(eval_me)
y <- "I am ready"
eval(eval_me)
```

Now you might wonder, in the `tidyverse` packages I can convenienently pass bare object names, there is no need to provide strings. This is possible in base R with the functions `quote()` and `substitute()`. They quote, which is capturing the expression.

```{r}
quote(x) %>% class()
```

`quote()` simply quotes its imput (creating an expression of the input without looking at it). 

If we want to quickly create a `name` from a string, instead of running `parse()` we can use `as.name`.

```{r}
as.name("x")
```
And finally to make matters nice and unclear, a name is also called as a `symbol` and the function `as.symbol()` does exactly the same as `as.name()`. Perfect, what's next? Lets call some functions.

## `call`

When we delaying the evaluation of a function call, we get to the second subcategory of expressions: the `call`. The function to be called with the names of the objects used for the arguments are stored untill further notice.

```{r}
wait_for_it <- quote(x + y)
class(wait_for_it)
x <- 3; y <- 8
eval(wait_for_it)
```

Note, that `+` is a function, like every action that happens in R. We have already seen that from a string we can get to an expression with `parse()`. Not surprisingly, `deparse()` gives a string from an expression. Allowing is to do stuff like.

```{r}
print_func <- function(expr){
  paste("The value of", deparse(expr), "is", eval(expr))
}
print_func(wait_for_it)
x <- 24
print_func(quote(x))
```

When the expression is a name, we print the name and the value of the object associated with the name. When it is a call, we print the function call and the evaluation of it.

## `closure`

Ow wait, in the last block we are writing a function in which we used some NSE stuff. No coincedence, NSE and functions are a strong and natural pair. We need to touch environments and closures here. I told you that an object is the binding of a name and a value, but I ommitted something here. It is the binding of a name and a value in an **environment**. When starting an R session, you act in the global environment. All objects created live in the global. 

```{r}
z <- 25
```

A function creates a new environment, objects of the same name can live here with different values binded to them.

```{r}
z_func <- function() {
  z <- 12
  z
}
z_func()
z
```

The z_func did not change the global environment, but created an object in its own environment. Now functions are of the strange type called a `closure`. 

```{r}
typeof(z_func)
```

They are called this way because they *enclose* their environment. At the time they are created they have a look around in the environment in which they are created (called the parent environment) and capture all the names that are available there. It thus does not only know the names of the objects in it own environment, but also in his parent's. And it can acces them. [Adv-R](http://adv-r.hadley.nz/functional-programming.html#closures). 

Not sure why I am telling you this, read on to formulas.

## `promise`

With the knowledge gained in the above we can start and try to write our own NSE function. Lets make a function that adds a column to a data frame that raises another column to a given power.

```{r}
add_squared <- function(x, col_name) {
  new_colname      <- paste0(deparse(col_name), "_sq")
  x[, new_colname] <- x[ ,deparse(col_name)]^2
  x
}
add_squared(mtcars, quote(cyl)) %>% head()
```

You might say, "that is not too convenient, I still need to quote the col_name". Well, you are very right, it would be more helpful if the function did the quoting for you. Unfortunately placing `quote(col_name)` inside the function body is of no use. `quote()` makes a literal quote of its input. So it would make the `name` *col_name* here, rather than quoting the value that was provided to this argument. 

Here we need `substitute()`. This will lookup all the object names provided to it, and if it finds a value for that name, it will substitute the name for its value [Adv-R](http://adv-r.hadley.nz/nse.html#substitute). Lets do a filter function to demonstrate.

```{r}
my_filt <- function(x, filt_cond) {
  filt_cond_q <- substitute(filt_cond)
  rows_to_keep <- eval(filt_cond_q, x)
  x[rows_to_keep, ]
}
my_filt(mtcars, mpg == 21)
```

Wait a minute, how does `eval()` now that *mpg* is a column in `x`. You provided `x` to the function, but how does this work. Well, the data frame `x`, was provided to the `envir` argument of `eval`. A data frame, thus, is a valid environment in which we can evaluate expressions. *mpg* lives in the data frame, so the evaluation of `filt_cond_q` here gives a valid result.

We need to get one more definition straight before we shift to tidy eval. When you think about it a little longer, NSE is only possible when function arguments are not evaluated right away. If the function was the inpatient kid that wanted to put `filt_cond` in its mouth right away, it would have failed to find an object with the name *mpg* in the above example. When the function is called, rather than evaluated right away, the provided argument are stored in a **promise**. The promise of the argument contains the value of the argument, but also an expression of the argument. The function does not bother about the value of the promise until the function argument is actually used in the function. The `substitute()` function can enter the expression of the promise. In the `my_filt()` example, the promise associated with the `x` argument will have the actual data frame belonging to the object `mtcars` as its value, and the name *mtcars* as its expression. In the second and third line of the function, the value is accessed. The promise associated with the `filt_cond` argument, does not have a value, only a call as an expression. As soon as we use this argument, the function would fail. We don't do this however, with `substitute()` we only access the expression of the promise.

Pff, that was a lot to swallow. Get a beer or a coffee, depending the time of the day. Maybe continue reading tomorrow. Anyway, we will continue with how tidy eval is different from base R NSE.

TODO formula

# Tidy eval

So we know that in the tidy verse, most things are reimplemented the way the H.D.S.L.G. sees fit. Now we know how base R does NSE, the easiest way to go is see how tidy eval does things differently.

## quosure

As we can guess from its name, this is a hybrid from a *quote* and a *closure*. Recapping what both are. When we quote a piece of R code we don't evaluate it, but rather store it to evaluate it later. A closure is an object that looks around at the time it is created, and sees what variables are available. Because of the enclosing you can build expressions that mix variables that live in the global environment, with the ones living in your data frame. Take the following `dplyr` example.

```{r, warning=FALSE, message=FALSE}
library(tidyverse)
global_var <- 1:32
mtcars %>% filter(mpg == 21 & global_var == 1)
```

```{r}
mtcars %>% my_filt(mpg == 21 & global_var == 1)
```








